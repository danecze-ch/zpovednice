Cookie Consent by _F_r_e_e_ _P_r_i_v_a_c_y_ _P_o_l_i_c_y_ _w_e_b_s_i_t_e
[Navigační _R_E_G_I_S_T_R_A_C_E [Navigační _T_A_B_L_O [Navigační _S_T_A_T_I_S_T_I_K_A [Navigační _SS_OO_UU_TT_?Ě_?Ž_EE [Navigační _P_O_M_O_Z_T_E [Navigační _R_E_K_L_A_M_A [Navigační _K_O_N_T_A_K_T [Navigační
    lišta]            lišta]           lišta]                lišta]             lišta]             lišta]             lišta]             lišta]
[Navigační lišta]
                            [Horní lišta bez menu]
                            _[_L_o_g_o_ _Z_p_o_v_ě_d_n_i_c_e_]
               [Dolní lišta]   [Dolní lišta]       [Dolní lišta]
               [Nabídka voleb] [Dolní lišta voleb]
   Otázky - Vzkazy č.1114383, vloženo _[_S_t_a_r_š_í_ _z_p_o_v_ě_ď_]_[_N_o_v_ě_j_š_í_ _z_p_o_v_ě_ď_]_[_H_l_a_v_n_í
   01.12.2019 23:36:47                _s_t_r_á_n_k_a_]
   C++ využití procesoru
   Ahoj, svůj kód mastím v c++ (SDL 2) a mám 4 jádrový(4 vlákna) phenom.
   Jde mi o to, že jsem si všiml, že mi využití procesoru(tím programem)
   vyskakuje až na 40-44%
   Moje otázka je proč? Kód mám rozdělený na 2 vlákna (1 zatěžuje procesor
   na 0% a v druhém pracuju s velkým polem, často allokuju a deallokuju
   paměť a ještě se tam starám o rendering)
   Teoreticky by mělo být využití max. 25%, proč tomu tak není? Navíc
   všechny jádra procesoru se zatíží rovnoměrně, nedává mi to smysl, když se
   to všechno děje v 1 vláknu
    Programátor [Muž]18  _V_Y_M_A_Z_A_T

Zaslaná rozhřešení _[_S_t_a_r_š_í_ _z_p_o_v_ě_ď_]_[_N_o_v_ě_j_š_í_ _z_p_o_v_ě_ď_]_[_H_l_a_v_n_í_ _s_t_r_á_n_k_a_]
Chceš dnes udělat dobrý skutek ? Pomoz výše uvedenému hříšníkovi tím, že mu
dáš nějaké rozhřešení! Můžeš mu ho poslat na e-mailovou adresu, kterou uvedl u
zpovědi, nebo napsat veřejně vyplněním formuláře na konci této stránky. A
jestliže nechceš, aby pod tvou přezdívkou mohl vystupovat ještě někdo jiný,
zaregistruj si ji _Z_D_E !
 
02.12.2019 20:07:30
<Catherine Zeta-Jones odhalila tajemství Hollywoodu a Dr. Oz, jak se zbavit
vrásek BEZ Botoxu nebo plastické chirurgie. Podívejte se, jak rozvedená
babička přelstil plastické chirurgy - a VY MŮŽETE TAKÉ!
V průběhu manželství, které trvalo několik desetiletí, pleť Patty Robertsové
se neustále zhoršovala a stárla díky stresu, nepravidelnému používání
opalovacího krému a příležitostné konzumaci vína a kouření.
Jakmile uslyšela, že ji její muž, se kterým byla v manželství po dobu 43 let,
nazval "starou vyschlou švestkou" , tato žena z Kalifornského Los Angeles se
rozhodla pro transformaci, která ji zbaví vrásek, aby se znovu cítila mladá,
sama sebou a sebevědomá - a výsledek? Z tváře si vymazala více jak 30 let!
Pokračujte ve čtení a dozvíte se, jak Patty Robertsová úspěšně omládla o
desítky let a pomstila se tak svému bývalému manželi používáním průkopnické
novinky Dr. Oz..

Poté, co se s ní manžel rozvedl, protože byla "příliš stará ", Patty
Robertsová si přísahala, že se pomstí svému bývalému manželi tím, že bude
vypadat stejně, jako zamlada. Že bude zase krásná, jako před dvaceti lety.
Přemýšlela o plastické chirurgii, ale protože ji její lékař vysvětlil, že v
jejím případě patří mezi "riskantní patienty", nemohla na operaci přistoupit.
Nicméně, co poté uslyšela v talk show ji změnilo život.

„ Když jsem byla mladší, moje pokožka byla napnutá a krásná a nikdy jsem měla
problémy s vráskami. Dokončila jsem vysokou školu, aniž bych měla na tváři
jedinou vrásku. Začala jsem pracovat v nedaleké firmě a vypěstovala jsem si
nezdravé návyky jako například to, že jsem nepoužívala krémy s UV filtrem,
pila alkohol a občas jsem si zapálila.
Postupem času se mi na tváři začaly objevovat vrásky. Čím dál tím více. Cítila
jsem se zle a zahanbeně ... Když jsem šla s přítelkyněmi ven, vždy jsem se
cítila nesvá, schovávala se na toaletách, kde jsem na sebe patlala spoustu
make-upu. Nelíbilo se mi, co jsem viděla v zrcadle, dokonce jsem se jim začala
vyhýbat.
Jednou jsem zaslechla, jak mě manžel řekl "stará vyschlá švestka" . Když jsem
se ho na to zeptala, přiznal se "BYL JSEM TI NEVĚRNÝ protože vypadáš staře!"
poté se se mnou rozvedl a žil se ženou, která byla mnohem mladší, než já!
Bolelo to a byl to hrozný šok. Do té doby jsem neměla ani ponětí, že si o mně
myslí, že vypadám tak staře. Zkrátka jsem si myslela, že je to chlap, který mě
nikdy neopustí, ani když budu opravdu stará a vrásčitá.
Zpočátku jsem ho nenáviděla! Doufala jsem, že bude litovat svých slov a činů.
Dnes jsem vděčná za to, co mi řekl, protože mě to motivovalo. Uvědomila jsem
si tak, že se musím začím o svou pleť starat, aby vypadala zdravější. Ne pro
jiné, ale pro mě samou. Kdybych nezměnila svůj životní styl, opravdu bych brzy
vypadala jako stará sušená švestka. Zírala jsem nějakou dobu do zrcadla,
podívala se na sebe, což bylo bolestivé, a věděla jsem, že s tím musím něco
rychle udělat!” "
Patty vyzkoušela různé meto
 REKLAMA
02.12.2019 20:03:23
Netvrďte mi že se to neučíte ve 3 třídě, já se to učil už v prvním ročníku a
za 30 let se nic nezměnilo. Ale to je ten váš arogantní přístup. Člověk vám tu
nabídne řešení a vy jste na něj ještě sprostý. Vy si pomoc nezasloužíte. Jste
jen vulgární hovado co někde na internetu objevilo C++ a teď si myslí že něco
umí ale umí hovno!!!
[Smajlík]
 GREGORIAN
02.12.2019 19:59:47
GREGORIAN
no tak to je jasné, za to může školství, jsem ve třetím ročníku a neučíme se
to!
[Smajlík]
 Programátor
02.12.2019 19:54:53
Jestli neumíte tak jednoduchou věc, která se učí již ve 2 ročníku střední
školy tak nechápu co tu vůbec řešíte. Prostě to smažte a jděte si hrát na
pískoviště
[Smajlík]
 GREGORIAN
02.12.2019 19:52:25
ale to lze jednoduše opravit derivátem telemetrické proměnné Fn a to tímto
kodem:

auto result_reverse = std::async([&str]() {
std::reverse(str.begin(), str.end());
});

A teď by to mělo být vyřešeno, děkovat netřeba
[Smajlík]
 GREGORIAN
02.12.2019 19:52:10
Teď se může stát že program skončí tímto chybovým kodem:
main.cpp: In function ‘int main()’:
main.cpp:18:71: erreur: no matching function for call to ‘async(<unresolved
overloaded function type>, std::basic_string<char>::iterator, std::
basic_string<char>::iterator)’
main.cpp:18:71: note: candidates are:
/usr/include/c++/4.6/future:1355:5: note: template<class _Fn, class ... _Args>
std::future<typename std::result_of<_Functor(_ArgTypes ...)>::type> std::async
(std::launch, _Fn&&, _Args&& ...)
/usr/include/c++/4.6/future:1378:5: note: template<class _Fn, class ... _Args>
typename std::__async_sfinae_helper<typename std::decay<_Functor>::type, _Fn,
_Args ...>::type std::async(_Fn&&, _Args&& ...)
main.cpp:18:71: erreur: unable to deduce ‘auto’ from ‘<expression error>’
main.cpp:20:62: erreur: no matching function for call to ‘async(<unresolved
overloaded function type>, std::basic_string<char>::iterator, std::
basic_string<char>::iterator)’
main.cpp:20:62: note: candidates are:
/usr/include/c++/4.6/future:1355:5: note: template<class _Fn, class ... _Args>
std::future<typename std::result_of<_Functor(_ArgTypes ...)>::type> std::async
(std::launch, _Fn&&, _Args&& ...)
/usr/include/c++/4.6/future:1378:5: note: template<class _Fn, class ... _Args>
typename std::__async_sfinae_helper<typename std::decay<_Functor>::type, _Fn,
_Args ...>::type std::async(_Fn&&, _Args&& ...)
main.cpp:20:62: erreur: unable to deduce ‘auto’ from ‘<expression error>’
 GREGORIAN
02.12.2019 19:52:06
GREGORIAN
bohužel template metaprogramming neumím
[Smajlík]
 Programátor
02.12.2019 19:51:33
Pokud to nepůjde, doporučuji vytvořit soubor .atp a separovat derivát proměnné
arg a spojit jí s tímto kodem:

#include <algorithm>
#include <future>
#include <string>

void foo(std::string::iterator first, std::string::iterator last)
{
}

template<class BidirectionalIterator>
void bar(BidirectionalIterator first, BidirectionalIterator last)
{
}

int main()
{
std::string str = "Lorem ipsum, dolor sit amet";

auto result_reverse = std::async(std::reverse, str.begin(), str.end()); /
/ Compile-time error
auto result_foo = std::async(foo, str.begin(), str.end());
auto result_bar = std::async(bar, str.begin(), str.end()); // Compile-time
error

result_reverse.get();
result_foo.get();
result_bar.get();
}
 GREGORIAN
02.12.2019 19:50:12
Tak já to zkusím vysvětlit jinak. Váš procesor disponuje jedním jádrem z
důvodu co jsem psal. Takže na to využijeme tento kod:
template< class Function, class... Args>
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>.. -
.)>> -
async( Function&& f, Args&&... args );

template< class Function, class... Args>
std::future<std::invoke_result_t<std::decay_t<Function>,
std::decay_t<Args>...>>
async( Function&& f, Args&&... args );

template< class Function, class... Args>
[[nodiscard]]
std::future<std::invoke_result_t<std::decay_t<Function>,
std::decay_t<Args>...>>
async( Function&& f, Args&&... args );


template< class Function, class... Args >
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>.. -
.)>> -
async( std::launch policy, Function&& f, Args&&... args );

template< class Function, class... Args >
std::future<std::invoke_result_t<std::decay_t<Function>,
std::decay_t<Args>...>>
async( std::launch policy, Function&& f, Args&&... args );
template< class Function, class... Args >
[[nodiscard]]
std::future<std::invoke_result_t<std::decay_t<Function>,
std::decay_t<Args>...>>
async( std::launch policy, Function&& f, Args&&... args );
 GREGORIAN
02.12.2019 19:16:31
Michal-222
můj procesor hyperthreading nepodporuje

no, chápu, že to může udělat paseku, ale právě u tý hry to je i rychlejší
jediný, v čem mám problém je to, že to způsobuje bugy(ale jenom při malém
frameratu)
-nestíhá se počítat zda něco kolidovalo, ale kdybych to sesynchronizoval s
fyzikou hry, tak by se stalo to, že by se hra naopak lagovala a popravdě já
mam radši bugy, než lagy :D
třeba si někdo bude schválně zapínat tu hru na slabších pc, aby využíval bugů
:D
jinak..
vykreslování.. prostě to vykreslí obraz, nic víc, nic míň, žádný výpočty
nejsou potřeba, není potřeba synchronizovat
vstup.. taky mi je jedno, kdy kontrolovat vstupy vzhledem k ostatním vláknům
počítání zátěže.. prostě to využije neaktualizovanou zátěž o pár ms.. to je
toho
fyzika a kolize.. bugy miluju
 Programátor
02.12.2019 18:47:42
Já tomu úplně nerozumím, jak tohle funguje.

Existuje nějaká možnost, jak nastavit afinitu vlákna či procesoru - že se dá
vybrat, na kterém procesoru vlákno poběží (v C# je na to funkce, v c++ určitě
taky, jen nevím jak se jmenuje).

Nechápu, proč jedno vlákno běží střídavě na různých procesorech, ale mám
pocit, že jsem se s tím už někde setkal (že to windows plánovač přiděluje
náhodně).

Taky existuje ještě nějaký hyper-threading, že se to z pohledu systému tváří
jako že to má dvojnásobný počet procesorů než ve skutečnosti, že ten jeden
procesor se tváří jako dva nezávislé (a asi ve chvílích, kdy první čeká, až mu
dorazí z paměti data, tak běží ten druhý) - má to asi větší výkon než kdyby
tam byl jen jeden, a menší než kdyby dva plnohodnotné...

PS: A synchronizaci bych nepodceňoval, to bývá zdrojem dost těžko
odhalitelných chyb...v uživatelském programu se nemusí moc řešit, jde li o
synchronizaci mezi vlákny či mezi procesory. Kdybys ale někdy psal drivery,
tak tam to principiální je...
 _M_i_c_h_a_l_-_2_2_2 [Muž]44 [Kategorie]
02.12.2019 18:22:22
Michal-222
tím multitaskingem jsem pouze chtěl říct, že si to mezi procesory může
rozdělovat.

ale vypadá to, že i to 1 vlákno si to střídá.
když si spustím třeba tento kód:
int main() {
int i = 0;
while (1) { i++; }
return 0;
}
zátěž se rozdělí mezi všechny procesory, takže se to střídá.
podle mě to dělá, aby to zátěž rozložilo rovnoměrně mezi všechny procesory -
aby to eliminovalo to, že 1 procesor pojede na 100% a další 3 na 1% třeba
no.. to už je asi to jak píšeš - náhodně to přiděluje.

ale.. tohle už je pro mě celkem nepodstatné, to co jsem chtěl vědět už vím

ten program mám rozdělený na několik vláken(vykreslování, vstup, počítání
fyziky, další co mi počítá využití procesoru(kód jsem našel) a posledních x
vláken pro počítání kolizí - x se snižuje při vysokém využití procesoru(>= 98%
tam mam tuším), naopak se zvyšuje)
vlákna nemám mezi sebou ani sesynchronizovaná a všechno funguje, jak má
[Smajlík]
 Programátor
02.12.2019 18:03:56
Michal-222

ad 2) Poustet jedno vlakno pokazdy na jinym procesoru nedava moc smysl a v
praxi nevim o scheduleru kterej by to delal. Jde o to ze prijdes o data v l1 a
l2 cache a jejich naplneni je nezanedbatelna rezie. Schedulery se obecne snazi
poustet tasky presne na tech corech kde uz jednou bezely, protoze je slusna
sance na l1/l2 cache hit, kterej je mnohem rychlejsi nez tahani dat z pameti.
Jedine co cestuje mezi cory jsou treba interupty, nicmene i ty se daji
bindnout na konkretni cory.

To je casto vyhodne napriklad treba na serverech kde mas numa architekturu,
protoze ti to dovoluje sdilet data v ramci numa node => zarizeni ma pridelenou
nejakou pamet ktera je z hlediska numa architektury nejhospodarnejc vyuzivana
nakym corem a tak je dobry mit interupty prirazeny na core kterej je na
stejnym numa uzlu paac sdilis casto l3 cache a data ti necestujou mezi cory/
sockety qpi linkou ci jak se to jmenuje.

Jinak tohle zajimavy tema. Casto totiz neni uplne prdel navrhnout hw
architelturu tak aby ti treba zvladla 10gbit provoz apod.
[Smajlík]
 Psoug
02.12.2019 17:50:01
>>>
Michal-222 ta druhá varianta je správná, ale teď mě napadá, že když to takhle
funguje, tak proč třeba GTA:SA zatíží 1 jádro na 100% místo 4 jader a každý na
25%?

to může nastat situace kdy si OS nemůže proces přehazovat mezi jádry? vždyť na
tom funguje celej multitasking, procesy se rychle střídají na procesoru.
<<<

Je třeba rozlišovat mezi mulitaskovým a multiprocesorovým...

Multitasking znamená, že se postupně provádějí jednotlivá vlákna (přepíná se
mezi nimi - taksswitch), takže to navenek vypadá, jako by běžely paralelně.

Když je více procesorů, tak si je vlákna "rozeberou" - takže některé věcí běží
skutečně paralelně (ne jen zdánlivě). Ale celé to má smysl, když je vláken
více než procesorů.

Pokud je vlákno jen jedno, není žádný velký užitek z toho, že jej vteřinu
necháme běžet na jednom procesoru a vteřinu zase na jiném. Trvá to úplně
stejně, jako by běželo jen na tom samém. Windows ale myslím procesory
přiděluje tak nějak náhodně...ale jedno vlákno může v jeden čas běžet jen na
jednom procesoru, program musí být prováděn sekvenčně, krok za krokem...
 _M_i_c_h_a_l_-_2_2_2 [Muž]44 [Kategorie]
02.12.2019 17:40:16
No, tak je to tím SDL.
zkusil jsem pustit kód pouze s renderingem a výsledek:využití cca 50%
a opak, ty práce s polem atd.. výsledek:25%
využití se může zdát vysoké, ale to počítám s tím, že nelimituju fps.

Díký všem za rady, hlavně tobě Psoug.

Michal-222 ta druhá varianta je správná, ale teď mě napadá, že když to takhle
funguje, tak proč třeba GTA:SA zatíží 1 jádro na 100% místo 4 jader a každý na
25%?

to může nastat situace kdy si OS nemůže proces přehazovat mezi jádry? vždyť na
tom funguje celej multitasking, procesy se rychle střídají na procesoru.
Vím je to stará hra, dříve se nepočítalo s multithreadingem, ale tohle je snad
práce OS
[Smajlík]
 Programátor
02.12.2019 17:09:12
No, čistě logicky by to mělo být tak, že:

1) To zatíží jedno jádro na 100%

nebo

2) To zatíží všechna jádra na dohromady 100%
(protože to paralelní vlákno nemusí nutně běžet pořád bez přerušení, a nemusí
tím pádem běžet pokaždé na stejném procesoru)

nebo

3) To zatíží všechna jádra každé na 100% (ale to už mi moc logické nepřipadá)

nebo

4) To zatíží každé jádro obecně libovolně

Poslední varianta mi nepřijde logická vůbec - a řešení bych hledal v tom, že
to buď překladač dokáže přeložit tak, že to běží paralelně na více
procesorech, nebo nevím...

Pokud voláš ze svého programu nějaké systémové služby (něco tady padlo s
alokací paměti) nebo nějaké cizí knihovny, je klidně možné, že ty běží na
jiných procesorech...

Také můžeš mít "vestavěnou grafickou kartu" - která také dokáže procesory
slušně zatížit.
 _M_i_c_h_a_l_-_2_2_2 [Muž]44 [Kategorie]
02.12.2019 16:20:52
GREGORIAN:
Asi jsi nepochopil o co mi jde, neřeším žádný problém s procesorem či jeho
neúměrnou zátěží a nebo tím, že mi nefunguje program, to bych potom přiložil i
kód.
program je tak udělaný(že zatíží procesor na max.)

Psoug:
Díký za radu, podívám se na to a zkusím to zjistit, potom napíšu jestli něco
zjistím
OS mám windows 10.
 Programátor
02.12.2019 15:16:16
Pokud bys uměl programovat tak se neptáš, takže tohle asi bude tvůj první
střet s programováním. V první řadě je potřeba si číst chybové hlášky a je
jedno jestlli programujete v C++ nebo čemkoliv jiném. Je tam jasně psané „The
compiler's setup (GNU GCC Compiler) is invalid, so Code::Blocks cannot find/
run the compiler.“. O kus dál se ptá „ Do you have a compiler installed?“ a
kde si to máš zkontrolovat. Co to má společného "s PC"? Je to přeci aplikace
základů fyziky ze ZDŠ a jisté význačné schopnosti našeho živočišného druhu!

- z malé plochy výkonové polovodičové součástky je nutno odvádět vznikající
tepelnou energii.

- v tomto případě na tepelný rozvaděč CPU (kus plechu na vrchu kryjící
substrát) přiléhá blok, kterým musí protékat chladící médium!

- teplo z chladícího média se dostává z výměníku, kde se předává do okolního
vzduchu.

- cirkulaci (oběh, tok) chladícího média zabezpečuje oběžné čerpadlo.

Kupodivu podobně funguje ústřední vytápění s nuceným oběhem, a to dávno před
vznikem IBM PC, že?

Takže, když není použitelná Poirotem oblíbená buňka:

- CPU je horký, aspoň podle měření v BIOSu a nejspíše před vypnutím stačí
maximální užívání ochranných opatření jako snížení napětí a frekvence jádra,
vkládání NOP, atd.

- je horký blok na CPU (kov je dobrý vodič tepla, stačí vedení od CPU)?

- jaká je teplota hadic v okruhu?

- jak teplý je výměník?

Když nefunguje cirkulace, nekoná se chlazení a v extrémním případě dojde
místně až k vývinu páry.
[Smajlík]
 GREGORIAN
02.12.2019 15:05:31
Chyba bude nejspíše v TLB, která se vyskytuje především u 4 jádrových
procesorů AMD Phenom. Tato chyba způsobuje nesmyslně vysokou zátěž procesoru.
Bohužel oprava není možná. Pokud byl procesor vyroben před rokem 2000 máte
smůlu, pokud po doporučuji kontaktovat správce vaši organizace a upozornit ho
na tuto chybu. Dále by měl správce kontaktovat centrum AMD a požádat o patch
pro procesor. Pokud problém přetrvává je to pravděpodobně kvůli stečení jader,
které se vyskytuje při problému se zdrojem, kdy zdroj způsoboval zkraty na
procesoru a tím ho vážně poškodil. Potom můžou všechny jádra začít fungovat
jako 1. V tom případě se obávám že nemáte jinou možnost než koupit jiný
procesor. Jinak nevím, protože problém není dostatečně specifikován. Buď je
vám málo let a pak vás omlouvá co jste napsal nebo jste takový fanda Intelu že
ignorujete historická fakta a pak je tu ještě možnost že máte krátkou
paměť.Faktem je že se to celé odehrálo poněkud jinak.Volání vývojářů různých
softů (dokonce i herních) po 64 Bit. CPU bylo čím dál více naléhavější zvláště
když je na snadě že takové CPU nespadne znebe jen tak a jeho vývoj bude
nějakou dobu trvat a prosazení také.Intel však ve své nadutosti že do čeho
nepůjde on tak to nebude existovat na tato volání odpovídal že 64 Bit.není
třeba a 32 Bit bohatě stačí.Jak se později ukázalo Intel řešení měl ale
kanibalizmus s CPU Itanium byl na snadě a pro Intel který měl na prosazení
Itania nesmírný zájem bylo jiné CPU nežádoucí (drsná ukáska kam vede dominance
na trhu).Tento přístup nahrál AMD které ucítilo šanci dát vývojářům to po čem
volají a zákazníkům pocit že mají něco lepšího.Faktem je že AMD přišlo s CPU
které umělo nativně jak 32 tak 64 Bit což bylo jako dar z nebes (umožnilo
pozvolnou migraci na 64 Bit.) a nikdo si nemohl přát více.Tlak vývojářů na MS
byl tak velký že jej nemohl MS už dál ignorovat a zahájil vývoj Win XP 64
Bit.Po roce když si Intel uvědomil že strácí nad vývojem situace kontrolu
přišel za MS s vlastním řešením ale byl MS odmitnut že 64Bit OS je již v
takovém stádiu vývoje že ho MS nehodlá zahodit a vzájemně nekompaktabilní
řešení nehodlá podporovat.To byla tehdá pro Intel rána jakou do te doby
neznal.Firmička která byla téměř po celou historii X86 CPU v háku a jen občas
z toho háku vyjela a šla s Intelem hlava hlava náhle určuje technologický směr
a on velký Intel se musí podřídit. V jednom měl Intel pravdu a to tu že by
takové CPU poškodilo Itanium což se opravdu stalo ale tak daleko AMD
neuvažovalo to chtělo jen uspět. Co si má z tohoto člověk odnést?No přece že
když někdo ovládá trh a začne se chovat tak že to co potřebuješ ty není pro
něj důležité proto že žiješ v bludu a co potřebuješ doopravdy ví přece nejlépe
on a pokud se ti to nelíbí nebudeš mít nic.Ještě že to AMD tady je. jednak
"64bit" CPU nemaji fyzicke 64bit adresovani, ale 36bitu, nebo aspon Nehalem
ale jestli ta technologie je odkoupena od AMD tak pochybuju ze to maji jinak.
Dal PAE umely i 32bit prcesory, proste jen
[Smajlík]
 GREGORIAN
02.12.2019 14:27:49
Dalsi vec je co dela treba ta sdl knihovna. Nektere jeji ulohy mohou totiz
bezet ve vice vlaknech, od graficky knihovny bych to koneckoncu i cekal. Ale
opet - vic Ti rekne ten profiling, kde bys mel jednoznacne videt co ti zabira
kolik casu.
 Psoug
02.12.2019 14:19:16
Pust si nejakej profiling at vidis co ty jadra skutecne delaji (na linuxu
treba prikaz perf, na windows netusim). Zkontroluj jakej je pomer mezi usr,
sys, interupty a wait times.

Jinak na tech procesorech zdaleka nebezi jen ten tvuj program. Urcite volas
nejaky systemovy volani, nejaka cast kernelu se musi starat o zminenou alokaci
ci dealokaci pameti, neco musi zpracovavat interupty, obsluhovat sockety, na
pozadi bezej jiny thready jinejch aplikaci atd apod.
 Psoug
02.12.2019 07:11:59
Zkus 3 jádra dačasně zaparkovat do "hangáru".
 Křemil
02.12.2019 01:04:55
Hov hov:
No nad tím jsem nepřemýšlel, asi to tak bude, díky za odpověď.
Zítra zkusím zjistit z jakou učástí to tak dokáže udělat, protože jsem si
jistej, že třeba u toho kódu co jsem napsal by to nepřekročilo 25%
 Programátor
02.12.2019 00:54:37
No tak asi proto, že ten tvůj kód není to jediný, co na počítadle běží. Ty
napíšeš kód a operační systém se stará, jak to rozdělit na jádra.
 _H_o_v_ _h_o_v [Muž]52 [Kategorie]
02.12.2019 00:26:59
Nevimuž:
Promiň, ale alokace jader nevím co je, strýček google to taky nevím
Co by to jako mělo dělat?
Kód rozdělím do vláken a tak dokážu využít víc jader procesoru, ale alokovat
je?
A můj pc nevyhodim
Ale dodám specifikace ať se trochu zasměješ:
Procesor:Amd phenom ii x4 955
Grafika: Nvidia GeForce gt 730(2GB)
Ram:6GB(2+4)
MB: Asus m4a785t-m
 Programátor
02.12.2019 00:20:18
Zdá se, že jsem to napsal nesrizumitelně, tak to zkusím znovu:
Mám 1 loop, třeba:
int i = 0;
while(1){
i =1;
}
Mě zajímá, proč mi takovej kód dokázal zatížit víc jader současně?
 Programátor
02.12.2019 00:19:04
Nechápu co tu řešíte. S takovým procesorem bych si nevytřel ani prdel. Nechápu
jak tahle řada nevyhrála titul nejhorší procesory všech dob. Kdyby udělal
program na vytváření bugů, tak by jich bylo míň než co mají tyhle procesory.
Prostě ho vem a zahoď ho. A celej zbytej pc adi taky. A jestli nevíš co je
alokace jádra tak rovnou přestaň s programováním.
[Smajlík]
 Nevimuž
02.12.2019 00:13:36
Redaktor:
Wtf? Nehostuju žádnej server
Hilomek:
Bohužel, správce úloh říká využito a ne idle
A i kdyby, pak by to, bylo 55-60% využití,ještě větší nesmysl
Kul58:
no.. Je to nesmysl.. Proto se na ti ptám,protože si to nedokážu vysvětlit proč
 Programátor
02.12.2019 00:10:46
Zkus tohle, mělo by ti to vyřešit tvůj problém a lépe to pak alokuje pole:

unsigned int reverse(register unsigned int x)
{
x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1));
x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2));
x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4));
x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8));
return((x >> 16) | (x << 16));
}
 Zpovednice
02.12.2019 00:07:03
To je nesmysl
 Kul58
02.12.2019 00:05:29
Kul58
Jasně, ale všechny mam na takt 3,2GHz,teoreticky by měli jet stejně a navíc ve
správci úloh to ukazuje, že to zatěžuje všechny jádra nějak a při spuštění
programu se všechny jádra rovnoměrně zatíží na těch cca 40%
 Anonym
02.12.2019 00:04:07
No.. To je ve skutečnosti procento nevyužití procesoru.. ;)
Tj. kolik času se procesor fláká..

Když máš v System Idle Process 90%, znamená to, že 90% času procesor nic
nedělá..
[Smajlík]
 Hilomek
02.12.2019 00:01:35
Jsou 2 možnosti: buď už vlákna budou většinu doby spát (nebudou žádná data)
nebo bude neustále plno dat a server nebude tak jako tak stíhat resp. bude se
prodlužovat doba odezvy. Takže je otázka, co je priorita.
 Redaktor
01.12.2019 23:58:29
Věc je v tom že při alokování jader to pak blbě jede. Taky je možný že jedno z
vláken je silnější než ostatní a taky to potom dělá jen to jedno vlákno a
zabírá to víc než 1/4. Chápeš? Mám z programování maturitu, angličtinu jsem
sice nedal ale němčinu ano, matika byla těžká ale šlo to, dřív totiž byla
ještě maturita z matiky víš !
 Kul58
01.12.2019 23:54:31
Kul58
1.Kde jsem napsal, že allokuju jádra?
2.proč sedí? Využití je 40-44=+%, 1vlákno u procesoru s 4 vlákny=25% nebo snad
ne?
[Smajlík]
 Programátor
01.12.2019 23:49:46
Tento inzerat od 100 ty sy asy dobry idyjot. Tento prcosef je velyce vykony
sam ho vyuzivam k rpogramovani a je velyce vykony ale ja pouzyvam jeho 1
jadrovoh varyantu ale i tak je velyce vykony ale problem je asy problem. v tom
ze tvoji grafycka karte nebo primo ve zdroji. protoze ve zdroji se deje
spoustu operaci ktere ovladaji soucadtky tak se obcas stane ze se ty tam neco
prehodi a to pak musys koupit novy zdroj z obchodu ale dneska jsoh zdroje
levne tak sy koipis nejaky. a nebi tu grafi ou kartu taky se my to stavalo ze
me ty proogramy pak blikaly a zarezovali moc tu graficku proceaor :)
 C++ programator
01.12.2019 23:45:54
Ty ale nemůžeš alokovat jádra a navíc využití sedí. Příště zkus Javu nebo
jinej procesor. Nevim co máš za blbej program ale je nefunkční asi.
 Kul58
01.12.2019 23:44:35
Uznávám, procesor je už dost starý, ale nejde mi o to, jak moc rychle to
stíhá, ale jde mi o to jak může využít více jader na 1 vláknovej program?
 Programátor
01.12.2019 23:39:20
Možná je to proto že tvůj procesor je dobrý akorát tak do kávovaru
[Smajlík]
 Tento inzerat od 100



 Přidání rozhřešení _[_S_t_a_r_š_í_ _z_p_o_v_ě_ď_]_[_N_o_v_ě_j_š_í_ _z_p_o_v_ě_ď_]_[_H_l_a_v_n_í_ _s_t_r_á_n_k_a_]
 TVÁ PŘEZDÍVKA:
 [jmenko              ]       _TT_ee_nn_tt_oo_ _ii_nn_zz_ee_rr_aa_tt_ _kk_oo_uu_pp_?í_tt_ee_ _oo_nn_--_ll_ii_nn_ee_ _oo_dd_ _11_00_00_ _KK_?č_..
 OPIŠ BEZPEČNOSTNÍ KOD:       _P_ř_i_d_e_j_ _i_n_z_e_r_á_t_ _o_n_-_l_i_n_e_ _o_d_ _1_0_0_ _K_č
 [Captcha]
 [code                ]

 PŘILOŽ SMAILÍKA:
 _[_S_m_a_i_l  _[_S_m_a_i_l   _[_S_m_a_i_l _[_S_m_a_i_l    _[_S_m_a_i_l   _[_S_m_a_i_l  _[_S_m_a_i_l   _[_S_m_a_i_l _[_S_m_a_i_l
 _P_a_l_e_c   _H_r_o_z_í_c_í_] _D_r_ž_í   _N_e_n_í_ _t_o   _D_o_s_t_a_n_e_š _S_m_u_t_n_ý_] _C_o_ž_e_?_?_]  _S_a_f_r_a_] _P_u_s_i_n_k_a_]
 _n_a_h_o_r_u_]          _p_a_l_e_c_] _d_ů_l_e_ž_i_t_é_] _d_o_ _h_u_b_y_]
 ojupííí otak     održím oto je    otumáááš oach jo ono nééé osafra ommmuc
         bacha    palec  fuk                        ?!
 (#žádný )

 [Odeslat rozh???e???en???]

 NNeejjlleepp?š?í cchhoorr?álloovv?á sskkuuppiinnaa ssvv?ěttaa...... _GG_RR_EE_GG_OO_RR_II_AA_NN_ _22_00_22_00 ......2200tthh AANNNNIIVVEERRSSAARRYY WWOORRLLDD
                                    TTOOUURR..

 REKLAMA
 Copyright 2003 www.zpovednice.cz + www.spovednica.sk



